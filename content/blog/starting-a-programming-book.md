+++
title = "Starting a programming book"
author = ["Robert Clay"]
date = 2022-01-26
lastmod = 2022-09-23T08:28:12+09:00
categories = ["topic"]
draft = false
+++

<span class="timestamp-wrapper"><span class="timestamp">[2022-01-26 Wed]</span></span>,#programming


## It's been a while {#it-s-been-a-while}

I took a break from writing in this blog after things got a bit busy at work.
But after some time away from it, I am looking forward to getting back to this
blog. Sorry if anyway was waiting for a new post... haha. I don't think any one
really reads this blog yet but maybe someday it will be useful to someone.


## So about that book {#so-about-that-book}

I bought a book: "Classic computer science problems in Python". It's taking me
through a bunch of classic problems you would get with a CS degree. I want to
take them and try to fill in some of the gaps in my knowledge. It's been a long
hard road learning on my own, and I think a book will be a great guide into some
topics and concepts that I would not run into if I didn't have someone guiding
me through.

That being said, it's kind of nice to be seeing a lot of topics that I have seen
before. It kind of makes me feel like I have been at least "in the ball park"
most of the time.


## I might be shooting a bit high {#i-might-be-shooting-a-bit-high}

I have mentioned lisp, and code, and some programming stuff in this blog before,
but I think this might be the first time I mention these languages as a group:

-   Elisp

-   C/C++

-   Erlang/Elixir/LFE (lisp flavored Erlang)

-   Python/Hy

These languages were selected for kind of odd reasons, but I have decided that I
want to be at least competent in all of these languages for various reasons.
Elisp is for Emacs, which is what I am writting this blog in, and I don't think
I will ever find a better note taking application than Org mode. C and C++ are
not what I want to write for fun, but I see so many languages built on them that
it kinds of feels like they are a sort of "lingua franca" of the coding world
and it would be nice to at least be able to get things done if a project
requires we get down close to the metal. Erlang, Elixir and LFE are languages
I just started looking into for a rather silly reason. I was pretty taken with
Clojure, but I had a horrible time with the Java and Javascript tooling. So I
decided to move to Elixir because while it doesn't have amazing support in
Emacs (a big package that used to be the defacto Emacs library for writing
Elixir is now unmaintained and the replacement LSP library is still getting some
of the features that used to be available built up), but the beam (the Erlang
virtual machine) has been much easier to get started with and I am happy to be
playing with very concurrent and functional code, and I can use it in three
different syntax.

Trying to learn all these languages at the same time is probably slowing me
down. But I don't think that is a very big problem for me. I don't have a
deadline for learning these (yet, haha) so taking my time and learning these
together feels like the right way to do things. I have imperative,
object-oriented, and functional all covered. And I think being able to think of
problems in all these languages kind of gets me to stop thinking in terms of the
code and more in terms of the mental model I build around working with these
kinds of problems.


## Learning in public {#learning-in-public}

I started listening to a few Elixir related podcasts on my morning commute, and
I have been enjoying "Thinking Elixir" and "Elixir Newbie" very much. I think
this bog can be my part of how I contribute back the community and also how I
learn more by teaching. Someone is going to be close to my level reading this
and find something useful that they were looking for, and I hope that I save
them some hours going and looking around the internet so they can get back to
doing things that are more fun.