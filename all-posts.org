#+STARTUP: content
#+AUTHOR: Robert Clay
#+HUGO_BASE_DIR: .
#+HUGO_AUTO_SET_LASTMOD: t
* Pages
  :PROPERTIES:
  :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :noauthor true :nocomment true :nodate true :nopaging true :noread true
  :EXPORT_HUGO_MENU: :menu main
  :EXPORT_HUGO_SECTION: pages
  :EXPORT_HUGO_WEIGHT: auto
  :END:
** Main page
   :PROPERTIES:
   :EXPORT_FILE_NAME: page-title
   :END:
   This will be on of the pages separate from the blog posts. It will be longer.

* Posts
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: blog
  :END:
** Topic                                                             :@topic:
*** TODO Post Title                                               :post:tags:
    :PROPERTIES:
    :EXPORT_DATE: 2017-12-19
    :EXPORT_FILE_NAME: post-title-in-slug-form
    :END:

    - State "TODO"       from "DONE"       [2020-12-15 Tue 22:31]
    Content

    More Content

    #+BEGIN_SRC bash -l 7 :hl_lines 8
      echo 'Some source code content'
      echo 'This line will be highlighted'
      echo "This one won't"
    #+END_SRC

**** Post Sub-Heading
     This is another section within the post.

*** TODO Draft Post Title
    :PROPERTIES:
    :EXPORT_FILE_NAME: draft-post-title
    :END:

    This article *will* be exported but will be marked ~draft = true~ in the front matter.

*** DONE First post
    :PROPERTIES:
    :EXPORT_FILE_NAME: bobby-test-post
    :EXPORT_DATE: 2020-12-13
    :END:
   [2020-12-15 Tue], #first_post
   
   This is the first of many posts to come. I had never considered my self a
   blogger type, but I have been learning some things recently and I feel like a
   blog is a great way to share what I have been learning in an ...oddly
   old fashioned manner. This past year I went from using Google docs to keep
   notes at work, to today finding myself unwilling to use anything less than
   Emacs and Org mode for a surprising amount of my day to day note taking and
   organization. It was a lot to learn, but the journey was worth it, and I hope
   to share not just what I have been learning about this past year (2020 was
   one for the record books in more ways than one), but I haven't really felt
   like I had a place to tell my story until now.

   These days all the young kids in Japan want to grow up and be a YouTuber.
   YouTube is a fascinating medium, and the amount of things you can learn and
   see there is staggering. But I have found myself gravitating to text these
   days and hope that a simple presentation can provide some counterpoint to the
   rest of the world that seems to be happily consuming ever increasing amounts
   of loud, noisy, colorful, and occasionally obnoxious video content in various
   forms.

   ...wow, I started off this blog with a little "get off my lawn" soap-box
   speech. This is going to be interesting. 
   
*** DONE What this Blog runs on
    :PROPERTIES:
    :EXPORT_FILE_NAME: what-this-blog-runs-on
    :EXPORT_DATE: 2020-12-16
    :END:
    [2020-12-16 Wed], #Emacs 
    This blog looks very simple on the surface, but what it is built on is
    something I am particularly happy with, and it will introduce a few themes
    and topics that I will write about more in the future. 

    Here is the loose chain of software and tech between my posts and the
    internet:
    - Emacs and org-mode
    - ox-hugo
    - Hugo static site generation
    - .git file for version control
    - Hosting of that .git file on Github
    - Github api calls to Netlify that runs a CI routine to build the site push
      it to the web.

      The fact I was just learning what Emacs was a year ago still makes me wish
      I had tried to learn all of this sooner. The number of powerful tools out
      there for people willing to learn them is incredible. And if I had learned
      how to use all this sooner, I wonder what I might have made when I was
      younger with more time on my hands.. lol.

      Just Emacs and Git have been a journey to learn, but now I have so much
      respect for what they can do as tools and how they let me do my work. And
      of all the things I could say about them I think I am most interested in
      talking about text files.
     
**** Text files? 
     Yeah, text files. You know, on your computer when you have a file that ends
     in .txt. That is a text files. Text files are awesome. I didn't think they
     were all that interesting until I learned what happened to files on a
     computer that are 10+ years old.

     I had a few laptops over the years, and I had never really given back-ups
     much thought because I am (was?) an Apple guy. I just turned on time-machine and
     called it a day. But these days when I try to get at **really** old files,
     I find a lot of those files don't open anymore. The data is there, but I
     can't use the program that made it. So even though I backed it up, the
     backup is useless. I still can't get at what I made. But do you know what I
     can still open? I had a diary app that let me do an export of my entire
     list of entries as an .rtf or rich text file. These files I can open, and
     they read just fine. That is because the .rtf file format is a widely
     adopted standard that lots of program can read and write to. But all my
     program that stored their information in proprietary formats are mostly
     useless now.

     So when I got to thinking about making this blog, I decided to make it here
     with a Hugo back-end. Hugo is a static site generation frame work built on
     Go, and while I don't know enough Go to be able to build it my self, have
     access to most the inner working of this site is really quite fun and
     interesting. To make a post, I just make a mark-down file, put it in the
     right spot in my file structure and I have a new blog post. I'll talk about
     Git and Emacs another day, but Org mode deserves some special mention.


    
**** Org mode

     Org mode is it's own markup language specific to Emacs and has a lot of
     support built into it for the lisp code (or elisp rather) it is built with.
     I have had to learn a bit of lisp, but as far as programming languages go I
     think it's not nearly as troublesome as languages like Javascript, but I
     digress. Suffice to say Org is a markup language, but at the end of the day
     it's also just text files. Meaning even if I needed to move away from Emacs
     and Org mode one day, all the words in my blog and notes will all be just a
     bunch of copy and paste of text to move somewhere else.

    ---
    I would not recommend this platform to everyone. The amount of reading I had
    to do to get it up and running was pretty substantial. And if you are
    thinking of making a blog I am sure tools and platforms like Word-press are
    much more approachable. But I really like what Hugo and Netlify and Emacs
    have afforded me here. I save an Org file and commit to a Git repository and
    I have posted a blog post. To me... that is the kind of powerful simplicity
    I want to use.

    
*** DONE Org mode introduction
    :PROPERTIES:
    :EXPORT_FILE_NAME: org-mode-introduction
    :EXPORT_DATE: 2020-12-17
    :END:
    [2020-12-17 Thu],#Org-mode
    
    This topic deserves more than a post or two, but it's a nice short introduction to
  what it is and how it works might help you understand why I have come to rely
  on Org mode for most of my note taking and task tracking needs.

    https://orgmode.org/manual/

    Let me start with why I went looking for and found Org mode. I was making
  really complicated spreadsheets at work. I was trying to program in a
  spreadsheet, and even convinced my company to get adopt a no-code tool. It was
  great. Lots of the power I wanted from a program but with the flexibility of a
  spreadsheet. I was so happy using it, I wondered it if might be nice to try
  and use it for my personal data management, and then I ran into a problem

**** It cost a monthly subscription fee
     Not that a monthly fee is all bad. The excellent company who made the
     software need to make money too. But I could not afford to be paying a
     monthly fee for software that I could do more or less with what I
     already had. I was much more interested in spending money on music
     software. 
   
     So I went online and started looking for software. I found a few text
     editors that did some of what I wanted, I tired Atom and thought it was
     pretty cool. But what I really wanted was something that would:
     - Tie in data in a spreadsheet with my words in my notes
     - Help me make notes, tasks, and track appointments without needing to use
       something like Google calendars
     - Approach code in terms of flexibility and let me make tools for what ever
       else I wanted it to do for me.

     


**** I don't remember the forum where someone suggested Org-mode, but I will forever be grateful for the advice I got

     I was warned that Org was hard to get set up, but that once you had it
     working it would do all those things I was looking to do and more.

     So let me get into what Org mode is. It's a "mode" for a  text editor
     called Emacs, and it's a markup language that has a few extra
     functionalities. Once of them is tables. While HTML tables are notoriously
     hard to type, format, and work with, Org mode makes them very easy and even
     provides most of what you would expect from a basic spreadsheet
     application... with one **very** big difference. Org mode also provides
     facilities for literate programming, meaning you can have cells in you
     spreadsheet that don't have to use the less than ideal "language" of
     spreadsheet formulas. You can write a Python function and have the result
     fill out into a column in your table. Something like this:
#+BEGIN_EXAMPLE
  #+TBLNAME: data_for_testing
  | number | Python |
  |--------+--------|
  |      1 |      2 |
  |      2 |      3 |
  |      3 |      4 |
  |      4 |      5 |
  #+TBLFM: $1='(org-sbe "Add_1_to_me" (num $1))
  
#+name:Add_1_to_me
#+begin_src python :python python3 :var num=1
return(num+1)
#+end_src
#+END_EXAMPLE

     Now any spreadsheet can add a number to the next cell's value, but the fact
     it can be written in a programming language as simple and powerful as
     python is one of the things that keeps me from looking anywhere else to do
     this sort of thing.

     I'll touch on the way the Python code is represented there later. Let me
     keep going on what I originally needed Org to do for me. I also wanted a
     way to write and keep notes. I had used Atom basic .md files, but Org did
     more than just give me a way to write notes. Because it is implemented in a
     Lisp interpreter, there are many things you can ask code to do for you
     based on what you write in your notes. Things like a special syntax to make
     something a "task" or a special syntax to make things a date which can be
     recognized else where to place notes and tasks relative to each other like
     a planner, it's really quite amazing how many things are in this software.
     And what really struck me was that fact it was basically all plain text
     and lisp code.

     I've mentioned lisp and code a few times, and while my intention was not to
     learn how to write code when I started using Org mode, I decided to try a
     little bit here and there and found that it wasn't as bad as the last time
     I had tried my hand at coding, and the "literate programming" style of
     writing prose with bits of code interspersed around the file was really
     nice. So I am teaching my slef a few languages, and one of them is elisp.
     
#+BEGIN_EXAMPLE
    #+name:example-code
    #+begin_src elisp
(cdr '(a b c d))
    #+end_src 

    #+RESULTS: exmaple-code
    | b | c | d |
#+END_EXAMPLE

    I won't bore you with a lisp tutorial, but suffice to say Org mode has made
    writing little bits of code that work together with words really easy. And
    surprisingly, you can mix languages. Because these blocks of code are
    independent in your document, you can define what they "see" from each other
    and string them together into a program with several languages in it. 

    My short introduction here hardly does the program justice, but if you want
    to know more, the link above can take you to the Org mode manual, which will
    tell most of what there is to know about it. If you are willing to learn how
    to use Emacs, Org mode is an amazing tool that made Emacs worth it for me.
    And after a while I started to find just how interesting Emacs it's self is
    too, but that is a topic for another day.

    
*** DONE Spacemacs
    :PROPERTIES:
    :EXPORT_FILE_NAME: spacemacs
    :EXPORT_DATE: 2020-12-21
    :END:
   [2020-12-21 Mon],#Emacs 

   Along with my search for an extensible note taking application and
   discovering Emacs and Org-mode, I also discovered Spacemacs (a set of
   configurations and settings for Emacs).
   
   https://www.spacemacs.org

   I didn't know what Vim was before I started reading the introduction on the
   Spacemacs home page. And that got me reading all kind of interesting articles on Vim, and
   how it's nice to know if you need to SSH into a sever you don't know and
   can't install any software. "vi" is going to be on that server, and it can
   run in a terminal session without any GUI. Modal text editing is not
   something I can used before, but having used several music synthesizers
   interfaces that have several function layers, I found the ideas of modes and
   functions for keys to be really easy to work with. When I installed Emacs and
   started playing with it, I didn't mind the use of "hjkl" for navigation.

   What I did find really confusing was vanilla Emacs and it's keybinding. I am
   slowly getting used to them now, and having something like Spacemacs
   probably slowed my progress when it came to learning Emacs it's self. But
   Spacemacs made Emacs really approachable with a lot of help along the way. I
   would definitely recommend Spacemacs to anyone looking to get into on of the
   deep text editors but doesn't feel they can handle vanilla Emacs right away.

   I found an article online that talked about not trying to pile more than one
   "learning curve" onto of another. If you don't know how to run a terminal and
   are trying to get into terminal Emacs, you have two unfamiliar things you are
   trying to learn at the same time. By only tackling them one at a time, you
   get to deal with each problem one at a time.

   In my case I was trying to juggle the following:
   - Widows
   - WSL (Windows subsystem for linux)
   - Building Emacs from source
   - Emacs
   - Org-mode

     It was a bit of a mess at first, and I can smile now as I think of all the
     things I had to go though to get it all working. When I was trying to get
     it set up there were a lot of issues that plagued just WSL, but now there
     are many guides you can find online to help you get started like this one:
     
     https://github.com/hubisan/emacs-wsl

     WSL was a great option for getting Emacs installed an running, but it
     created a lot of issues got me really confused about what was what. Emacs
     can run terminal emulators inside it... so if I can't run a program is it
     because it is only in Emacs? What is Python environment? What is a virtual
     environment? Why are some environment variables different in Emacs verses
     a bash shell? I had a lot of things to learn and one could argue that I
     took the hard way.

     ...but it was worth it. If you are at all interested in trying out Org mode
     and don't know if you can handle Emacs without help, I would heartily
     suggest you give Spacemacs a try. Personally I am looking to move to Doom
     in the next few weeks. Doom is like Spacemacs in that it is a pre-made
     configuration, but it's crazy fast, and while not as user friendly as
     Spacemacs, I think I can learn to work with it now. 

     As I make the transition to Doom, I will be sure to post my thoughts and
     impressions here on this blog. One more resource on Emacs and Spacemacs
     before I wrap this post up:

     Spacemacs: Installation, Configuration, and Navigation Tutorial
     By: Jack of Some
     https://www.youtube.com/watch?v=fdLCuJcS2Aw

     This tutorial really got me set up and going. If there is one thing that
     struck me with Spacemacs, it was how nice and welcoming and helpful people
     were in helping me get up and going.
     


*** DONE Software talking to software
    :PROPERTIES:
    :EXPORT_FILE_NAME: software-talking-to-software
    :EXPORT_DATE: 2020-12-27
    :END:
[2020-12-27 Sun],#software
This post is going to be a little less focused than other posts on the same
subject, but I feel I have a unique perspective to share from someone who is
just getting into this space. Sometimes it's hard to see further down the rabbit
hole to see how far down it goes, and it can be hard to see above you and how far
down you have come. A lucid moment to reflect on where you are can be nice not
only to redirect yourself, but maybe also to help others decide if this rabbit
hole they are heading down is really worth it.

**** A long chain of software

I am a computer musician. I used to think of the synthesizer as my instrument of
choice, but after using a few real hardware synthesizers I realized that I am
more interested in what computers afford me as far as sound possibilities and
music structure manipulation goes. As a computer musician I have played with and
used a variety of software over the years, but find myself constantly
gravitating to the software that is the most extensible. I was a big Logic Pro
user for many years, and I was very happy to have the complicated (but powerful)
"environment" available to me if I needed Logic to behave in a way that wasn't
the standard that most users expected.

Eventually I moved to Ableton Live, and the user experience is not so far
removed from Logic (they are both modern and capable DAWS), but Live provides me
with an API. There is a similar (but far less extensive API) connection in Logic
now that lets you write Javascript to control Midi information, but Live decided
to open up their software to "talk" to a program called MaxMSP made by cycling
'74. Having recently discovered how nice it is to work with text, I also found a
way to "talk" to MaxMSP via Node. And since I don't particularly want to learn
Javascript, I found a way to write node application in a language I DO want to
learn, Clojurescript. The resulting string of connections looks like so:

|   | Software      | functionality            |
|---+---------------+--------------------------|
| 1 | Live          | Music creation           |
| 2 | MaxMSP        | Visual programming       |
| 3 | Node          | Javascript Runtime       |
| 4 | Clojurescript | Functional LISP language |
| 5 | Emacs         | Text editor              |

**** Why all this complexity?
Most people are happy to simply make music in Live, or write code in a text
editor. Why go through the trouble of connecting the two? In my case, it's
because I like to use my tools for more than one purpose. If I am going to go
out of my way to learn something, I want it to be useful for more than just one
thing. Knowing how to use a computer is useful for more than just one thing. I
can use lots of other tools better by knowing how to use a computer. But if I
were to lean how to use a platform like say... Evernote, I would need to learn
how it works for basically only one thing, making and manipulating Evernote
files. Evernote can do all kinds of things, but it's a lot more closed off to
integrating with other tools than say the way a sound file made in your audio
recorder app could plug into any other piece of software that can read standard
audio file formats. Evernote files are basically only useful to Evernote.

These bits of software all provide for a way to work with them from the outside.
This means I can turn to external solutions if the tool at hand can't handle it.
If I have a bit of midi information in Live that I want to say... change based
on the number of files in a folder, I can tell Live to ask Max. Max can take the
bit of Midi and handle the request, but it's not very good at working with the
file system. Thankfully Node can talk to my computer's file system just fine, so
I use Emacs to write some Clojurescript that tells Node how to tell Max how
many files are present so Live can give me the result I was looking for. Could I
have done this without all this work? Sure. I can count files. I can give Live a
number and have it give me my sound. But I can't be bothered to do that several
hundred times in a row.

**** Is it worth it?

The million dollar question to be sure. Just because it's possible to make all
these things talk together doesn't make it a good idea. Just because a piece of
music can be influenced by the number of files in a folder doesn't mean it will
make for good music. But in my case there is another reason for wanting to
connect all these tools together.

- All these tools I would use on their own for their own use cases whether they
  could talk to each other or not.
- Learning each tool on their own not only benefits my use of that tool, but
  also makes it easier to pass that along to the rest of the chain.
- The ends of the chain make things I have more than one use for. Being able to
  connect them makes spending time at either end that much more useful to the
  opposite end.

Code is useless if it doesn't do something useful. And if the code I learn to
make for work can benefit my music making, I want to see where that leads me.
The music I make in Ableton Live might be fun to make, but it's also my way of
giving my music back through my volunteering at church. Having a direction to go
with my code, having a useful thing to do with my code besides work makes it
that much easier to find the energy on my days off, on my own time, to learn a
lot of complicated ...stuff.

**** Software talking to software is very powerful

Having used computers for the majority of my schooling and all thought out my
still evolving professional career, I see how the line between people talking to
software and software talking to software is a space I wish I had learned more
about sooner. I spent many many hours learning how to use software as an
end-user. That was fun, but user interfaces change, and eventually all that work
can end up being lost time if that software no longer exists, or doesn't run on
your current system. But once you take yourself out of the equation and get
software talking to software, you get something really special.

I had an issue at work. I needed to look at a bunch of Json data all at once not
because I had a program to write, but because a service we use at work will
only give me Json files. I was using Emacs to look at the files (which was a lot
better than using notepad) but I ended up saving my self the most time once I
taught a piece of software to do it for me. I still need to connect the Json to
the software I wrote, but the result is a LOT of simple tasks done over and over
in a way that means I only need to download some files, press a few buttons and
wait a few seconds.

There was a situation I had playing music at church one day. I only had one
sustain pedal for my keyboard, and I needed another one. The church service was
starting in 45 min, and I needed to figure out what to do with what I had. So I
coded one in MaxMSP. It was crude, it was fickle, but it got me through the
church service. Being able to tell software how to behave like a sustain pedal
and having it do that for me was invaluable in that moment. But if I had only
ever gone as far as being a end-user of software like Ableton Live, I would have
been stuck.

**** ...as long as you can manage the complexity

Yes, these tools are great, and I like them partly for the fact that they talk
to each other so well. But I do pay for it; in complexity. These tools are not
simple, and the interfaces that they use to talk to each other have each
frustrated me to no end in their own way. But to me I feel it's worth it.
Because I can deal with the complexity given enough time. I don't need this
music for my work. I don't even need to use code at work. But both happened to be
things I enjoy learning about and using. So while I wouldn't say the average
user should go out and try to connect all their tools to each other, the synergy
that results can be really exciting. Just be careful which tools you try to
connect. Nothing against JavaScript, but there is a reason I decided to talk to
Node with Clojurescript and not JavaScript.

*** DONE MaxMSP hold switch
    :PROPERTIES:
    :EXPORT_FILE_NAME: MaxMSP-hold-switch
    :EXPORT_DATE: 2021-01-03
    :END:

   [2021-01-03 Sun],#MaxMSP
**** Making your own tools can be a rewarding challenge

Being a computer musician, I appreciate the ability to work with data as it suits me. I don't need to just accept a stream of midi and ask a software synthesizer to make sounds for me. I can manipulate that stream of data in interesting ways before I put it to use. One such use I found for this manipulation is replicating a feature of a keyboard I sold a few years back.

I used to own a Roland JD-XA. It was a really analogue synth with some modern and cool features. Sadly, my audio recording set up was not up to doing it justice, and I ended up using it mostly as a controller. I sold it to get a Roli Seaboard instead and I am very happy with it. But I did miss a button on its front panel; the "hold" switch that went with the arpeggiator. The switch when used with the arpeggiator let you hold out the notes in a sequence even when you took you hands off the keys, but I liked the fact it wasn't tied to the arpeggiator itself. When it wasn't used with the arpeggiator, it acted like an "auto-sustain-pedal". Notes played legato were all sustained, and a new "set" of notes would trigger a re-pedal and the bee set of notes would sustain while the old notes would stop. It was super fun to use in conjunction with a two tier keyboard set up. I could play a piano like patch in my lower keyboard while the top board would be set to some sustaining patch that I could play a few notes on without needing to stand on a sustain pedal the whole time.

I was thinking unwound be able to get something similar from other arpeggiators, so I didn't think much of it when I sold the board. But after a few attempts with a few arpeggiator plugins, I quickly realized that this wasn't how most arpeggiators worked. But I also knew I had Max4Live. I figured I could just make my own.

**** What I wanted to make

Before I get into how I started trying to make this, I want to spell out exactly how it was supposed to work.

+ A "mode" needed to be enabled and easy to turn off.
+ That mode needed to know when notes were still being played or not
+ All note offs needed to be captured and handled in a special way
+ If there were no notes being held, a list of note offs for the currently sustaining notes would be to be calculated and sent before the new note on.

On the surface it seemed to be a really simple problem. Very clear order of operations, nothing that was too complicated, I thought it would take me 30 minutes to whip something up. Boy was I wrong.

**** The first few tries did not go well

My first attempt quickly spiraled out of control into a mess of complexity.
Generating a list of notes that were currently being held down on a keyboard
connected to this utility proved really hard to make and deal with. I had
considered making a dictionary where I added note-on events as entries and
note-off events as a sign to remove the entry. But having worked with some
Clojure at this point I wanted a solution that didn't rely on something mutable like this "dictionary" I was planning on relying on. Writing the "state of the midi stream with each new event lead to a huge mess of operation order. Do I read the dictionary before of after I compare the note coming in to the others to see if it's a note already in the list? Should the dictionary read be part of the clean up at the end of the chain? When does the note off list get generated? How I can generate that list without having the dictionary pass its contents all over the place? Do I need the contents of the dictionary in multiple places? It was a disaster.

Imagining the problem was Max, I proceeded to wire up Max and Node and ClojureScript, hoping that a different language would have better support for what I was trying to do. But after spending more time with Max, I found a better way forward.

**** But then I found out Max had already solved the problem for me

Max has an object that simulates what a sustain pedal does. While the "pedal" is down, all note offs are kept back. And when you send it the right message, all the current notes are ended with their corresponding note-off messages. This object solved 50% of what I was trying to do. I no longer needed to handle the creation of the note off messages. It even gave me a set of configurations for working with note-on overlap. I had originally split the midi note messages into note-on and note-off messages because I assumed I needed to count them to know how many notes were being held down, but it turns out there was a Max object for that too. Borax is an interestingly named object that reports various things about the state of a stream of midi. One of those bits of information is how many notes are currently "being held" from the stream of data.

So to wire it all up I only needed to:
+ check to see the number of notes held now.
+ If zero, open a gate
+ Bang on the gate. If it's open send start the sequence to send the notes offs.
+ The notes-off messages are send by controlling something like a sustain pedal, so using a delay I "lift" and "depress" the sustain pedal.
+ Pass along the midi message to then "sustain object".

Now that it's all finished, I can call up a bit of code that runs in Ableton
Live with just a few keystrokes whenever I want to. It replicates what my old
keyboard used to do, but with the flexibility of being implemented in MaxMSP
coda rather than tied up in a piece of hardware. I learned a lot about Max and
I hope this makes my next project that much easier to get started on.
**** The MaxMSP object for those interested
```MAXMSP
{
	"boxes" : [ 		{
			"box" : 			{
				"maxclass" : "newobj",
				"text" : "patcher hold-switch",
				"numinlets" : 3,
				"numoutlets" : 1,
				"id" : "obj-46",
				"outlettype" : [ "int" ],
				"patching_rect" : [ 712.000016808509827, 413.666671216487885, 145.0, 24.0 ],
				"patcher" : 				{
					"fileversion" : 1,
					"appversion" : 					{
						"major" : 8,
						"minor" : 1,
						"revision" : 8,
						"architecture" : "x64",
						"modernui" : 1
					}
,
					"classnamespace" : "box",
					"rect" : [ 1059.0, 84.0, 955.0, 1003.0 ],
					"bglocked" : 0,
					"openinpresentation" : 0,
					"default_fontsize" : 12.0,
					"default_fontface" : 0,
					"default_fontname" : "Arial",
					"gridonopen" : 1,
					"gridsize" : [ 15.0, 15.0 ],
					"gridsnaponopen" : 1,
					"objectsnaponopen" : 1,
					"statusbarvisible" : 2,
					"toolbarvisible" : 1,
					"lefttoolbarpinned" : 0,
					"toptoolbarpinned" : 0,
					"righttoolbarpinned" : 0,
					"bottomtoolbarpinned" : 0,
					"toolbars_unpinned_last_save" : 0,
					"tallnewobj" : 0,
					"boxanimatetime" : 200,
					"enablehscroll" : 1,
					"enablevscroll" : 1,
					"devicewidth" : 0.0,
					"description" : "",
					"digest" : "",
					"tags" : "",
					"style" : "",
					"subpatcher_template" : "Default Max 7",
					"assistshowspatchername" : 0,
					"boxes" : [ 						{
							"box" : 							{
								"maxclass" : "newobj",
								"text" : "unpack",
								"numinlets" : 1,
								"numoutlets" : 2,
								"id" : "obj-6",
								"outlettype" : [ "int", "int" ],
								"patching_rect" : [ 319.333338856697083, 340.0, 47.0, 22.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "inlet",
								"numinlets" : 0,
								"numoutlets" : 1,
								"id" : "obj-5",
								"outlettype" : [ "bang" ],
								"patching_rect" : [ 460.0, 30.0, 30.0, 30.0 ],
								"comment" : "",
								"index" : 3
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "button",
								"numinlets" : 1,
								"parameter_enable" : 0,
								"numoutlets" : 1,
								"id" : "obj-34",
								"outlettype" : [ "bang" ],
								"patching_rect" : [ 475.666665613651276, 107.333334505558014, 66.0, 66.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "newobj",
								"text" : "route 0",
								"numinlets" : 2,
								"numoutlets" : 2,
								"id" : "obj-32",
								"outlettype" : [ "", "" ],
								"patching_rect" : [ 371.666667461395264, 178.0, 46.0, 22.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "newobj",
								"text" : "pack",
								"numinlets" : 2,
								"numoutlets" : 1,
								"id" : "obj-30",
								"outlettype" : [ "" ],
								"patching_rect" : [ 337.0, 732.0, 37.0, 22.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "newobj",
								"text" : "midiparse",
								"numinlets" : 1,
								"numoutlets" : 8,
								"id" : "obj-28",
								"outlettype" : [ "", "", "", "int", "int", "", "int", "" ],
								"patching_rect" : [ 211.0, 200.0, 92.5, 22.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "newobj",
								"text" : "midiformat",
								"numinlets" : 7,
								"numoutlets" : 2,
								"id" : "obj-25",
								"outlettype" : [ "int", "" ],
								"patching_rect" : [ 216.0, 785.0, 82.0, 22.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "gswitch2",
								"numinlets" : 2,
								"parameter_enable" : 0,
								"numoutlets" : 2,
								"id" : "obj-40",
								"outlettype" : [ "", "" ],
								"patching_rect" : [ 191.0, 117.333334505558014, 39.0, 32.0 ],
								"int" : 1
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "newobj",
								"text" : "t l b",
								"numinlets" : 1,
								"numoutlets" : 2,
								"id" : "obj-39",
								"outlettype" : [ "", "bang" ],
								"patching_rect" : [ 319.333338856697083, 295.00000274181366, 44.0, 22.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "newobj",
								"text" : "gate",
								"numinlets" : 2,
								"numoutlets" : 1,
								"id" : "obj-27",
								"outlettype" : [ "" ],
								"patching_rect" : [ 496.666665613651276, 388.333338856697083, 37.0, 22.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "button",
								"numinlets" : 1,
								"parameter_enable" : 0,
								"numoutlets" : 1,
								"id" : "obj-26",
								"outlettype" : [ "bang" ],
								"patching_rect" : [ 496.666665613651276, 423.000006556510925, 24.0, 24.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "message",
								"text" : "1",
								"numinlets" : 2,
								"numoutlets" : 1,
								"id" : "obj-24",
								"outlettype" : [ "" ],
								"patching_rect" : [ 453.333342850208282, 577.666677832603455, 29.5, 22.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "message",
								"text" : "0",
								"numinlets" : 2,
								"numoutlets" : 1,
								"id" : "obj-22",
								"outlettype" : [ "" ],
								"patching_rect" : [ 413.666667520999908, 577.666677832603455, 29.5, 22.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "newobj",
								"text" : "delay 10",
								"numinlets" : 2,
								"numoutlets" : 1,
								"id" : "obj-20",
								"outlettype" : [ "bang" ],
								"patching_rect" : [ 496.666665613651276, 468.000000536441803, 66.0, 22.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "newobj",
								"text" : "== 0",
								"numinlets" : 2,
								"numoutlets" : 1,
								"id" : "obj-17",
								"outlettype" : [ "int" ],
								"patching_rect" : [ 496.666665613651276, 333.999996542930603, 37.0, 22.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "newobj",
								"text" : "borax",
								"numinlets" : 3,
								"numoutlets" : 9,
								"id" : "obj-16",
								"outlettype" : [ "int", "int", "int", "int", "int", "int", "int", "int", "int" ],
								"patching_rect" : [ 371.666667461395264, 413.000005483627319, 103.0, 22.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "toggle",
								"numinlets" : 1,
								"parameter_enable" : 0,
								"numoutlets" : 1,
								"id" : "obj-15",
								"outlettype" : [ "int" ],
								"patching_rect" : [ 360.999999284744263, 632.666671693325043, 24.0, 24.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "newobj",
								"text" : "sustain",
								"numinlets" : 3,
								"numoutlets" : 2,
								"id" : "obj-12",
								"outlettype" : [ "int", "int" ],
								"patching_rect" : [ 320.999999284744263, 669.666671335697174, 59.0, 22.0 ]
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "outlet",
								"numinlets" : 1,
								"numoutlets" : 0,
								"id" : "obj-4",
								"patching_rect" : [ 191.0, 860.0, 30.0, 30.0 ],
								"comment" : "",
								"index" : 1
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "inlet",
								"numinlets" : 0,
								"numoutlets" : 1,
								"id" : "obj-3",
								"outlettype" : [ "int" ],
								"patching_rect" : [ 311.000009179115295, 24.0, 30.0, 30.0 ],
								"comment" : "",
								"index" : 2
							}

						}
, 						{
							"box" : 							{
								"maxclass" : "inlet",
								"numinlets" : 0,
								"numoutlets" : 1,
								"id" : "obj-2",
								"outlettype" : [ "int" ],
								"patching_rect" : [ 192.833338856697083, 24.0, 30.0, 30.0 ],
								"comment" : "",
								"index" : 1
							}

						}
 ],
					"lines" : [ 						{
							"patchline" : 							{
								"source" : [ "obj-6", 0 ],
								"destination" : [ "obj-16", 0 ],
								"order" : 0
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-6", 1 ],
								"destination" : [ "obj-16", 1 ],
								"order" : 0
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-6", 0 ],
								"destination" : [ "obj-12", 0 ],
								"order" : 1
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-6", 1 ],
								"destination" : [ "obj-12", 1 ],
								"order" : 1
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-5", 0 ],
								"destination" : [ "obj-34", 0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-40", 0 ],
								"destination" : [ "obj-4", 0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-40", 1 ],
								"destination" : [ "obj-28", 0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-39", 0 ],
								"destination" : [ "obj-6", 0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-39", 1 ],
								"destination" : [ "obj-27", 1 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-34", 0 ],
								"destination" : [ "obj-26", 0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-32", 0 ],
								"destination" : [ "obj-26", 0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-30", 0 ],
								"destination" : [ "obj-25", 0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-3", 0 ],
								"destination" : [ "obj-40", 0 ],
								"order" : 1
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-3", 0 ],
								"destination" : [ "obj-32", 0 ],
								"order" : 0
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-28", 0 ],
								"destination" : [ "obj-39", 0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-28", 1 ],
								"destination" : [ "obj-25", 1 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-28", 2 ],
								"destination" : [ "obj-25", 2 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-28", 3 ],
								"destination" : [ "obj-25", 3 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-28", 4 ],
								"destination" : [ "obj-25", 4 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-28", 5 ],
								"destination" : [ "obj-25", 5 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-28", 6 ],
								"destination" : [ "obj-25", 6 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-27", 0 ],
								"destination" : [ "obj-26", 0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-26", 0 ],
								"destination" : [ "obj-22", 0 ],
								"order" : 1
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-26", 0 ],
								"destination" : [ "obj-20", 0 ],
								"order" : 0
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-25", 0 ],
								"destination" : [ "obj-4", 0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-24", 0 ],
								"destination" : [ "obj-15", 0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-22", 0 ],
								"destination" : [ "obj-15", 0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-20", 0 ],
								"destination" : [ "obj-24", 0 ],
								"midpoints" : [ 506.166665613651276, 563.0, 462.833342850208282, 563.0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-2", 0 ],
								"destination" : [ "obj-40", 1 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-17", 0 ],
								"destination" : [ "obj-27", 0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-16", 2 ],
								"destination" : [ "obj-17", 0 ],
								"midpoints" : [ 402.166667461395264, 449.0, 481.999999284744263, 449.0, 481.999999284744263, 329.0, 506.166665613651276, 329.0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-15", 0 ],
								"destination" : [ "obj-12", 2 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-12", 0 ],
								"destination" : [ "obj-30", 0 ]
							}

						}
, 						{
							"patchline" : 							{
								"source" : [ "obj-12", 1 ],
								"destination" : [ "obj-30", 1 ]
							}

						}
 ],
					"styles" : [ 						{
							"name" : "Nord",
							"default" : 							{
								"color" : [ 0.56078431372549, 0.737254901960784, 0.733333333333333, 1.0 ],
								"fontname" : [ "Source Code Pro" ],
								"textcolor_inverse" : [ 0.925490196078431, 0.937254901960784, 0.956862745098039, 1.0 ],
								"bgcolor" : [ 0.298039215686275, 0.337254901960784, 0.415686274509804, 1.0 ],
								"locked_bgcolor" : [ 0.180392156862745, 0.203921568627451, 0.250980392156863, 1.0 ],
								"clearcolor" : [ 0.180392156862745, 0.203921568627451, 0.250980392156863, 1.0 ],
								"bgfillcolor" : 								{
									"type" : "gradient",
									"color1" : [ 0.376471, 0.384314, 0.4, 1.0 ],
									"color2" : [ 0.290196, 0.309804, 0.301961, 1.0 ],
									"color" : [ 0.290196, 0.309804, 0.301961, 1.0 ],
									"angle" : 270.0,
									"proportion" : 0.39
								}
,
								"stripecolor" : [ 0.180392156862745, 0.203921568627451, 0.250980392156863, 1.0 ],
								"editing_bgcolor" : [ 0.231372549019608, 0.258823529411765, 0.32156862745098, 1.0 ],
								"textcolor" : [ 0.847058823529412, 0.870588235294118, 0.913725490196078, 1.0 ],
								"accentcolor" : [ 0.505882352941176, 0.631372549019608, 0.756862745098039, 1.0 ],
								"elementcolor" : [ 1.0, 1.0, 1.0, 1.0 ],
								"selectioncolor" : [ 0.92156862745098, 0.796078431372549, 0.545098039215686, 1.0 ]
							}
,
							"parentstyle" : "",
							"multi" : 0
						}
 ]
				}
,
				"saved_object_attributes" : 				{
					"description" : "",
					"digest" : "",
					"globalpatchername" : "",
					"tags" : ""
				}

			}

		}
 ],
	"appversion" : 	{
		"major" : 8,
		"minor" : 1,
		"revision" : 8,
		"architecture" : "x64",
		"modernui" : 1
	}
,
	"styles" : [ 		{
			"name" : "Nord",
			"default" : 			{
				"color" : [ 0.56078431372549, 0.737254901960784, 0.733333333333333, 1.0 ],
				"fontname" : [ "Source Code Pro" ],
				"textcolor_inverse" : [ 0.925490196078431, 0.937254901960784, 0.956862745098039, 1.0 ],
				"bgcolor" : [ 0.298039215686275, 0.337254901960784, 0.415686274509804, 1.0 ],
				"locked_bgcolor" : [ 0.180392156862745, 0.203921568627451, 0.250980392156863, 1.0 ],
				"clearcolor" : [ 0.180392156862745, 0.203921568627451, 0.250980392156863, 1.0 ],
				"bgfillcolor" : 				{
					"type" : "gradient",
					"color1" : [ 0.376471, 0.384314, 0.4, 1.0 ],
					"color2" : [ 0.290196, 0.309804, 0.301961, 1.0 ],
					"color" : [ 0.290196, 0.309804, 0.301961, 1.0 ],
					"angle" : 270.0,
					"proportion" : 0.39
				}
,
				"stripecolor" : [ 0.180392156862745, 0.203921568627451, 0.250980392156863, 1.0 ],
				"editing_bgcolor" : [ 0.231372549019608, 0.258823529411765, 0.32156862745098, 1.0 ],
				"textcolor" : [ 0.847058823529412, 0.870588235294118, 0.913725490196078, 1.0 ],
				"accentcolor" : [ 0.505882352941176, 0.631372549019608, 0.756862745098039, 1.0 ],
				"elementcolor" : [ 1.0, 1.0, 1.0, 1.0 ],
				"selectioncolor" : [ 0.92156862745098, 0.796078431372549, 0.545098039215686, 1.0 ]
			}
,
			"parentstyle" : "",
			"multi" : 0
		}
 ],
	"classnamespace" : "box"
}
```
* Footnotes
* COMMENT Local Variables                                           :ARCHIVE:
# Local Variables:
# eval: (auto-fill-mode 1)
# eval: (org-hugo-auto-export-mode)
# End:
